# Publish/Deploy your app

## Deployment pipeline

The main purpose of the continuous integration and deployment (CI/CD) pipeline is to create/build applications artifacts (Docker images for the web application and associated mobile application bundles) and deploy them in production-like environments in order to test it. The global CI/CD pipeline is illustrated in the following schema:

![Deployment pipeline](./../../assets/cd-pipeline.svg)

It comes in three different flavors, as defined by the value of the `NODE_APP_INSTANCE` environment variable:
* **dev**: in order to deploy current development/alpha version, linked to the `master` branch
* **test**: in order to deploy current staging/beta version, linked to the `test` branch
* **prod**: in order to deploy current production version, linked to `tags` on the `test` branch

**TODO**

## Prerequisites

### Install Change log generator

In order to be able to generate the changelog for your published app/modules you need this [gem](https://github.com/skywinder/github-changelog-generator), which creates a log file based on **tags**, **issues** and merged **pull requests** (and splits them into separate lists according to labels) from :octocat: GitHub Issue Tracker. This requires you to install (e.g. for Windows) [Ruby](http://rubyinstaller.org/downloads/) and its [DevKit](https://github.com/oneclick/rubyinstaller/wiki/Development-Kit).

### Configure application and third-party services

As an application often relies on third-party services its configuration must include secrets like API keys, passwords, etc. In this section we detail how we manage it in a secure way.

Depending on the services you need you will have to do the following:
* Generate a secret to secure your authentication, use one generated by the Feathers CLI
* Create a Firebase app in the [Firebase Console](https://console.firebase.google.com)
  * retrieve the `google-services.json` to be stored as a secret file in the *cordova* directory
  * create an Android app in your Firebase app and keep track of secret server key in *Parameters > Cloud Messaging*
* Create a GCM application in the [AWS SNS console](https://eu-west-1.console.aws.amazon.com/sns/v2/home) using the previous server key
  * keep track of app ARN
* Create a new project for your app in the [Google Cloud Console](https://console.cloud.google.com)
  * Activate the Google+ API on your project
* Create an OAuth2 ID for a Web App in [Google Cloud Console](https://console.cloud.google.com) > *API & services*
  * the redirect URL should match *your.domain/auth/google/callback*
  * download the *json* dans keep track of client ID and secret 
* Create an OAuth2 App in [GitHub](https://github.com/organizations/kalisio/settings/applications)
  * the redirect URL should match *your.domain/auth/github/callback*
  * download the *json* dans keep track of client ID and secret
* Create an AWS user in [IAM](https://console.aws.amazon.com/iam/home) with access to S3 API (e.g. *AmazonS3FullAccess*)
  * keep track of access key ID and secret
* Create a bucket for your app in the Kalisio account
  * keep track of its name
* Create an AWS user in [IAM](https://console.aws.amazon.com/iam/home) with access to SNS API (e.g. *AmazonSNSFullAccess*)
  * keep track of access key ID and secret

::: tip
Note: some of the previous accounts/IDs are not app specific and can be share accross multiple apps, e.g. S3, SNS, etc.
:::

Create required environment variables in a script file you can source before launching your app:
```
export APP_SECRET=xxx
export GOOGLE_MAIL_USER=xxx
export GOOGLE_MAIL_PASSWORD=xxx
export SNS_ACCESS_KEY=xxx
export SNS_SECRET_ACCESS_KEY=xxx
export SNS_ANDROID_ARN=xxx
export S3_ACCESS_KEY=xxx
export S3_SECRET_ACCESS_KEY=xxx
export S3_BUCKET=xxx
export GITHUB_CLIENT_ID=xxx
export GITHUB_CLIENT_SECRET=xxx
export GOOGLE_CLIENT_ID=xxx
export GOOGLE_CLIENT_SECRET=xxx
```

Then, retrieve this variables in config files like this:
```
github: {
  clientID: process.env.GITHUB_CLIENT_ID,
  clientSecret: process.env.GITHUB_CLIENT_SECRET
}
```

In your local development environment you should use the script to setup all the required secrets. This script should be safe-guarded in a non-public environment.

::: danger
You should never store production passwords or other sensitive production data in a clear form in source code or config files.
:::

::: warning
You shouldn't use production secrets in development and test mode.
:::

### Configure CI/CD

We heavily rely on [Travis CI](https://travis-ci.org) for continuous integration and delivery, as such you need to create the CI/CD pipeline in Travis CI by syncing your GitHub repository.

To set up the CI/CD pipeline, sensitive data are needed to access the required services (SSH, third-party, etc.) and **should not be pushed under source control unless you use private repositories or encryption**.

#### Secret variables

If some of the sensitive data are stored using environment variables, you have to use [encrypted environment variables](https://docs.travis-ci.com/user/environment-variables/) set either in build file or repository settings.

::: warning
If you'd like to set a value holding multilines or special characters take care to surround it with `"` so that it will be properly escaped.
:::

#### Secret file

If you need additional sensitive data stored through [files](https://docs.travis-ci.com/user/encrypting-files/) create a *secrets.tar* containing all secured files and encode it to *secrets.tar.enc* a using [Travis CLI](../../tools/cli.md#travis-cli). This file will be decrypted before the build or whenever you need something inside.

Indeed, as mentioned in the [documentation](https://docs.travis-ci.com/user/encrypting-files/#Encrypting-multiple-files), it is not possible to encrypt multiple files and thus requires to create a `tar` file containing the different secret files and encrypts the archive. 

The table below lists for example the required files to publish a mobile app using Cordova:

| File | Description |
|:-----|:------------|
| keystore file| A binary file containing the private key of the certificate you need to sign the Android app |
| cordova build file | A Json file used by Cordova to sign the generated application. It uses the keystore file |
| google play service account | A Json file storing the data needed to use the Google Play service account |
| google services account | A Json file storing the the keys to access the various Google services |

You need to be logged into Travis CI before generating the secret file like this:
```
tar cvf secrets.tar your_keystore.keystore build.json google-play.json google-services.json
travis encrypt-file secrets.tar
```

## Plugins/Modules

The same process applies when releasing a patch, minor or major version, i.e. the following tasks are done:
* increase the package version number in the **package.json** file (frontend and backend API)
* publish the module on the NPM registry
* create a tag accordingly in the git repository and push it
* generates the changelog in the git repository and push it

::: tip
Modules are published under the `@kalisio` namespace with a `kdk` prefix in NPM, e.g. `kCore` NPM package is named `@kalisio/kdk-core`
:::

::: warning
This requires you to have a NPM and GitHub account and be a team member of the Kalisio organization, if you'd like to become a maintainer please tell us
:::

Depending on the release type the following command will do the job (where type is either `patch`, `minor`, `major`):
```bash
yarn/npm run release:type
```

::: warning
If you have a lot of issues/PRs to be integrated in change log please [generate a GitHub token](https://github.com/github-changelog-generator/github-changelog-generator#github-token) to avoid rate-limiting on their API and set the `CHANGELOG_GITHUB_TOKEN` environment variable to your token before publishing**
:::

::: danger
The changelog suffers from the following [issue](https://github.com/github-changelog-generator/github-changelog-generator/issues/497) so you might have to edit the generated changelog when pushing on different branches**
:::

::: warning
Before you publish a plugin take care of updating the version of your dependent plugins to the latest version published, for example  perform `yarn upgrade kCore` for a plugin depending on the core plugin before publishing it**
:::

## Web app

Almost the same process applies as for the plugins/modules except the app is not published on the NPM registry, i.e. the following tasks are to be done:
* increase the package version number in the **package.json** file (frontend and backend API)
* create a tag accordingly in the git repository and push it
* generates the changelog in the git repository and push it

::: warning
Before you publish your app take care of updating the version of all dependent plugins to the latest version published, for example  perform `yarn upgrade kCore kTeam`
:::

Depending on the release type the following command will do the job (where type is either `patch`, `minor`, `major`):
```bash
yarn/npm run release:type
```

::: warning
Depending on the app the push of tags or changlog is more or less automated in order to have more control so that youd could have more scripts to run in order to complete the publication
:::

Because Kalisio web app are also released as Docker images you can build it like this:
```bash
docker build -t kalisio/kapp .
```
Then release it as latest version:
```bash
docker login
docker push kalisio/kapp
```
And tag it (`version_tag` being the current version number like `1.1.2`)
```bash
docker tag kalisio/kapp kalisio/kapp:version_tag
docker push kalisio/kapp:version_tag
```

::: warning
This requires you to have a DockerHub account and be a team member of the Kalisio organization, if you'd like to become a maintainer please tell us
:::
